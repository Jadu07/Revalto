generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum AcademicYear {
  First
  Second
  Third
  Fourth
}

enum Hostel {
  Your_Space_01
  Your_Space_02
  UniSpace_Boys
  UniSpace_Girls
}

enum Gender {
  Male
  Female
  Others
}

enum Condition {
  NEW
  LIKE_NEW
  GOOD
  FAIR
  POOR
}

enum WarrantyPeriod {
  NO_WARRANTY 
  LESS_THAN_1_MONTH
  ONE_TO_THREE_MONTHS
  THREE_TO_SIX_MONTHS
  SIX_TO_NINE_MONTHS
  NINE_TO_TWELVE_MONTHS
  MORE_THAN_1_YEAR
}

enum RequestStatus {
  PENDING
  NEGOTIATING
  REJECTED
  COMPLETED
}

enum PaymentType { 
  ADVANCE
  FULL
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
}

model User {
  id                 Int          @id @default(autoincrement())
  name               String
  email              String       @unique
  password           String // stores bcrypt hash
  anonymousName      String       @unique
  gender             Gender
  phone              String       @unique
  hostel             Hostel
  roomNumber         Int
  isVerified         Boolean      @default(false)
  isProfileAnonymous Boolean      @default(true)
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  imgUrl             String?
  annonymousImgUrl   String?
  academicYear       AcademicYear

  // Relations
  posts            Post[]
  purchaseRequests PurchaseRequest[]
  ordersAsBuyer    Order[]           @relation("BuyerOrders")
  ordersAsSeller   Order[]           @relation("SellerOrders")
  conversationsAsA Conversation[]    @relation("UserA")
  conversationsAsB Conversation[]    @relation("UserB")
  messagesSent     Message[]
}


model Post {
  id                  Int       @id @default(autoincrement())
  itemName            String
  itemImgUrl          String // Cloudinary image URL
  description         String    @db.Text
  originalPrice       Float
  secondHandPrice     Float
  condition           Condition
  warrantyRemaining   WarrantyPeriod
  isAvailable         Boolean   @default(true)
  isPostedAnonymously Boolean   @default(true)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  authorId            Int
  author              User            @relation(fields: [authorId], references: [id], onDelete: Cascade)
  purchaseRequests    PurchaseRequest[]
  orders              Order[] 

  Conversation Conversation[]
}

model PurchaseRequest {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  status    RequestStatus @default(PENDING) 

  // Relations
  postId    Int
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  buyerId   Int
  buyer     User     @relation(fields: [buyerId], references: [id], onDelete: Cascade)

  order        Order[]
  conversation Conversation?

  @@unique([postId, buyerId])
}


model Order {
  id                Int           @id @default(autoincrement())
  createdAt         DateTime      @default(now())
  amount            Float // Amount paid (could be partial or full)
  paymentType       PaymentType   @default(ADVANCE)
  paymentIntentId   String        @unique // From Stripe/Razorpay
  paymentStatus     PaymentStatus @default(PENDING) // <-- This is the only status now

  // Relations
  postId            Int
  post              Post            @relation(fields: [postId], references: [id])
  buyerId           Int
  buyer             User            @relation("BuyerOrders", fields: [buyerId], references: [id])
  sellerId          Int
  seller            User            @relation("SellerOrders", fields: [sellerId], references: [id])
  purchaseRequestId Int
  purchaseRequest   PurchaseRequest @relation(fields: [purchaseRequestId], references: [id])
}

model Conversation {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  // Relations
  userAId   Int
  userA     User     @relation("UserA", fields: [userAId], references: [id])
  userBId   Int
  userB     User     @relation("UserB", fields: [userBId], references: [id])

  postId    Int
  post      Post     @relation(fields: [postId], references: [id])

  purchaseRequestId Int @unique
  purchaseRequest   PurchaseRequest @relation(fields: [purchaseRequestId], references: [id])

  messages Message[]

  @@unique([userAId, userBId, postId])
}

model Message {
  id             Int      @id @default(autoincrement())
  text           String
  createdAt      DateTime @default(now())

  // Relations
  conversationId Int
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId       Int
  sender         User         @relation(fields: [senderId], references: [id])
}

